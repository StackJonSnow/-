## 概述
对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像C/C++程序开发程序员这样为内一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。

## 运行时数据区域
* 线程共享
1.程序计数器
2.虚拟机栈
3.本地方法栈

* 线程私有
1.堆内存
2.方法区（这个 java1.8 以后被移动到了直接内存中，叫做元空间）

### 程序计数器：
可以理解为字节码的行号指示器，是 jvm 运行时数据区域中唯一一个不可能发生内存溢出异常的区域。程序计数器有两个作用：1.帮助字节码解释器确定执行位置，实现程序流程控制，比如 if/else，循环，异常捕获。2.在发生线程上下文切换时，可以记录当前线程执行的字节码位置，下次线程上下文恢复时可以继续执行。

### 虚拟机栈
描述 java 方法执行的内存模型，每次方法调用数据都是通过栈传递的。虚拟机栈是由栈帧组成的，每个方法调用就会产生一个栈帧，栈帧是由局部变量表，操作数栈，方法出口等信息组成，方法调用完毕对应栈帧的弹出。
虚拟机栈会发生 StackOverflowError 和 OutOfMemoryError。
StackOverflowError：栈溢出异常，如果方法请求的深度大于栈允许的最大深度时，就会发生此异常。
OutOfMemoryError：如果栈允许自动扩展，那么当申请的内存超过扩展允许的上限时，便会抛出此异常。如果栈不允许自动扩展，那么申请的内存超过栈的最大内存时，也会抛此异常。

### 本地方法栈
跟虚拟机栈类似，只是本地方法栈是用来实现本地方法的调用管理。在 hotspot 虚拟机中将虚拟机栈与本地方法栈合二为一了。

### 堆
jvm 中最大的一块内存，用来存储对象实例，是 gc 管理的主要区域。堆分为新生代与老年代，新生代又分为 eden 区和 survivor 区，survivor 区还分为 from survivor 和 tosurvivor。

### 方法区
存储类，静态变量等类的元信息。字符串常量池：用于存放编译期生成的各种字面量和符号引用。

## 创建一个对象的过程
1.加载前检查
2.分配内存
3.初始化零值
4.设置对象头
5.执行 init 方法

### 加载前检查
.class 文件加载时，需要先检查该类是否被加载过，文件是否符合规范等。
### 分配内存
在堆内存中为对象分配一块合适大小的内存，分配方式分为两种：1.指针碰撞，适合堆内存规整的情况，所谓规整是指堆内存中已使用的内存是连续的，未使用的内存也是连续的，那么只需要一个指针去记录使用的内存与未使用内存的分界点地址，然后移动对象所需要的内存大小的地址空间就实现了对象内存的分配。2.空闲列表，适合堆内存不规整的情况，jvm 维护一个列表，里面记录着堆内存中有哪些内存块使用过，哪些内存块没使用过，在没使用过的内存块中找到一个合适大小的内存块就实现了对象内存的分配。内存的规不规整取决于 jvm 使用的 gc 算法是标记整理还是标记清除。

### 初始化零值
在分配好内存后，给对象属性分配初始化值，比如给引用类型属性赋值为 null， 给整型属性赋值为0，保证在这些属性没有被赋值的情况下可以被使用。

### 设置对象头
对象除了要存储类中定义的成员变量等信息外，还需要对象头，对象头中存储着对象对应的类的元信息存储的地址位置，对象的 hash 值，gc 年龄，锁标识等信息。

### 执行 init 方法
即执行构造器，保证对象的自定义初始化。

## 对象访问定位
1.句柄
2.直接指针

### 句柄
在堆中维护一个句柄池，虚拟机栈中引用指向句柄，句柄再定位到对象地址和类元信息地址。这里有一个好处是，在对象地址改变时，不需要修改对象引用，维护句柄池就好。但是这样有一个缺点，定位一个对象需要两步。

### 直接指针
虚拟机栈中直接存储对象地址，但是类的元信息地址就存储在对象头中。这么做访问对象比句柄访问方式快，缺点就是需要考虑类元信息地址存储和在对象地址改变时，需要同步修改引用值，比如发生 gc 后。

## 判断对象已死
1.引用计数法
2.可达性分析

### 引用计数法
给对象添加一个引用计数器，每有一个引用指向该对象，计数器就加一，当计数器的值为 0 时，意味着没有任何引用指向该对象，此对象就可被回收。这种方法的优点就是实现比较简单，效率也比较高，但是没办法解决循环引用的问题。

### 可达性分析
将一系列 GC Roots 对象作为起点，向下遍历，遍历路径成为引用链，如果一个对象到 GC Roots 没有引用链，那么就代表这个对象处于游离状态，可以被回收。

## 对象的引用类型
1.强引用
2.软引用
3.弱引用
4.虚引用

### 强引用
如果一个对象有一个强引用指向他，那么 gc 时就不会回收该对象。日常编程中使用的大部分引用就是强引用。

### 软引用
当内存够用时，gc 不会回收被软引用指向的对象，但当内存不够用时就会回收掉这类对象。软引用可以用来实现内存敏感的告诉缓存。可以与一个 ReferenceQueue 关联，对象被垃圾回收后，jvm 会将引用放进与之关联的 ReferenceQueue 中去。
### 弱引用
不管内存是否够用，都会回收被弱引用指向的对象。可以与一个 ReferenceQueue 关联，对象被垃圾回收后，jvm 会将引用放进与之关联的 ReferenceQueue 中去。

### 虚引用
虚引用不会决定对象的生命周期，虚引用指向的对象任何时候都可能被垃圾回收，虚引用必须与 ReferenceQueue 联合使用 ，虚引用存在的意义是可以跟踪垃圾收回收的过程。比如，如果判断 ReferenceQueue 中存在虚引用，那么就可以知道垃圾回收正在发生，并且可以在对象内存被回收掉之前做一些程序处理。

## 垃圾回收算法
1. 标记清除
2. 复制算法
3. 标记整理
4. 分代收集

### 标记清除
先将可回收对象进行标记，然后一次性清除，这么做的问题是可能会导致产生很多内存碎片，不利于新对象的内存分配。

### 复制算法
将堆内存分为两半，每次只使用其中一半，当一半使用完后，对可回收对象进行标记回收，存活的对象移动至另一半内存。这么做虽然可以解决内存碎片的产生，但是内存利用率太低。

### 标记整理
是标记清除与复制算法的优化版，先将可回收对象标记，然后回收，回收完后将存活对象往堆内存同一个方向移动，保证存活对象内存区域连续。这么做解决了标记清除内存碎片问题和复制算法内存利用率不高问题，但是多了一步内存整理，耗时较长。

### 分代收集
将对象分为新生代与老年代，针对不同的对象采用不同的垃圾收集算法，比如新生代对象一般都是会大量产生并且生命周期短，可以使用复制算法，老年代对象生命周期长可以使用标记清除或标记整理算法。

## 垃圾收集器
1.serial
2.parnew
3.cms
4.g1


### serial
串行收集器，采用单线程做垃圾收集，在垃圾收集过程中需要停止 jvm 中其他线程，收集效率低，会造成程序停顿，但是这种收集器比较简单，适合没有高性能要求的 clien 模式下的 jvm。

### parnew
serial 收集器的多线程版本，比 serial 高效，适合 server 模式下的 jvm。

### cms
实现了垃圾收集线程与工作线程基本上可以同时工作，大大缩短了垃圾收集时程序停顿的时常。

### g1
是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.







 
